"""
CordGuard Codes Module

This module contains utility functions for generating unique IDs and extracting timestamps from them.
The IDs are used throughout CordGuard for tracking analysis jobs and files.

Key Components:
-------------
- create_trackable_id(): Generates unique trackable IDs with embedded timestamps
- extract_timestamp_from_trackable_id(): Extracts original timestamps from IDs
- TIMESTAMP_HARDCODED_OFFSET: Constant offset used to obscure timestamps
- PREFIX_ANALYSIS_ID: Standard prefix for all analysis IDs

ID Format:
---------
The trackable IDs have the following format:
cordguard_<hash><random>_<encoded_timestamp>

Where:
- cordguard: Static prefix for all IDs
- hash: First 10 chars of SHA256 hash of the timestamp 
- random: Random number between 0-180000000
- encoded_timestamp: Hex encoded original timestamp

Example ID:
cordguard_a1b2c3d4e590123456_5f3e2d1c

Usage:
-----
    # Create a new trackable ID
    timestamp = int(datetime.now().timestamp())
    id = create_trackable_id(timestamp)
    
    # Extract timestamp from an ID
    dt = extract_timestamp_from_trackable_id(id)

Dependencies:
-----------
- hashlib: For SHA256 hashing
- secrets: For secure random number generation
- datetime: For timestamp handling
- logging: For debug logging

Author: CordGuard Security Team <security@cordguard.org>
Maintained by: Abjad Tech Platform <hello@abjad.cc>
Version: 1.0.0
"""
import hashlib
import secrets
from datetime import datetime
import logging
logging.basicConfig(level=logging.INFO)

TIMESTAMP_HARDCODED_OFFSET = 134897
PREFIX_ANALYSIS_ID = 'cordguard'

def create_trackable_id(timestamp: int = int(datetime.now().timestamp())) -> str:
    """
    Creates a unique analysis ID combining a hashed timestamp, random number, and encoded timestamp.
    
    The ID has three parts separated by underscores:
    1. First 10 chars of SHA256 hash of the current timestamp shifted by TIMESTAMP_HARDCODED_OFFSET
    2. Random number between 0-180000000 (generated by adding two random numbers 0-90000000) 
    3. Hex encoded original timestamp appended at the end to allow extracting
       the creation time later while still maintaining ID uniqueness
    
    The final format is: "<prefix>_<hash><random>_<encoded_timestamp>"
    For example: "cordguard_a1b2c3d4e590123456_5f3e2d1c"
    
    Args:
        timestamp (int): Unix timestamp to use for ID generation. Required.
    
    Returns:
        str: Analysis ID in format described above
        
    Example:
        >>> create_trackable_id(1633027200)
        'cordguard_a1b2c3d4e590123456_5f3e2d1c'
    """
    encoded_timestamp = hex(timestamp - TIMESTAMP_HARDCODED_OFFSET)[2:] # Remove the '0x' prefix
    logging.info(f'Encoded timestamp: {encoded_timestamp}')
    hashed_timestamp = hashlib.sha256(encoded_timestamp.encode('utf-8')).hexdigest()[:10]
    logging.info(f'Hashed timestamp: {hashed_timestamp}')
    random_number = str(secrets.randbelow(90000000) + secrets.randbelow(90000000))
    logging.info(f'Random number: {random_number}')
    full_analysis_id = hashed_timestamp + random_number + '_' + encoded_timestamp
    logging.info(f'Full analysis ID: {full_analysis_id}')
    return PREFIX_ANALYSIS_ID + '_' + full_analysis_id

def extract_timestamp_from_trackable_id(trackable_id: str) -> datetime:
    """
    Extracts the original timestamp from an analysis ID and converts it to a datetime object.
    
    The function expects an analysis ID in the format:
    "<prefix>_<hash><random>_<encoded_timestamp>"
    
    It extracts the encoded timestamp portion, converts it from hex back to an integer,
    adds back the TIMESTAMP_HARDCODED_OFFSET, and returns a datetime object.
    
    Args:
        analysis_id (str): The analysis ID to extract timestamp from
        
    Returns:
        datetime: Datetime object representing when the analysis ID was created
        
    Raises:
        ValueError: If the analysis ID format is invalid (doesn't have 3 underscore-separated parts)
        
    Example:
        >>> extract_timestamp_from_trackable_id('cordguard_a1b2c3d4e590123456_5f3e2d1c')
        datetime(2021, 10, 1, 0, 0, 0)
    """
    trackable_id_parts = trackable_id.split('_')
    if len(trackable_id_parts) != 3:
        raise ValueError("Invalid trackable ID format")
    
    timestamp_hex = trackable_id_parts[2]
    logging.info(f'Timestamp hex: {timestamp_hex}')
    # Convert hex directly to integer
    timestamp_int = int(timestamp_hex, 16)
    logging.info(f'Timestamp int: {timestamp_int}')
    return datetime.fromtimestamp(timestamp_int + TIMESTAMP_HARDCODED_OFFSET)
